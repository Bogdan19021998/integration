package ai.distil.integration.job.destination;

import ai.distil.api.internal.model.dto.datasource.DTODataSourceAttributeExtended;
import ai.distil.api.internal.model.dto.destination.DestinationIntegrationDTO;
import ai.distil.integration.job.destination.vo.CustomAttributeDefinition;
import ai.distil.integration.job.sync.AbstractSubscriber;
import ai.distil.integration.job.sync.http.AbstractHttpConnection;
import ai.distil.integration.job.sync.http.sync.SyncSettings;
import ai.distil.integration.job.sync.progress.SyncDestinationProgressData;
import ai.distil.integration.utils.ListUtils;
import ai.distil.model.org.CustomerRecord;
import ai.distil.model.types.DataSourceSchemaAttributeTag;
import ai.distil.model.types.DataSourceType;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static ai.distil.integration.job.sync.AbstractSubscriber.HASH_CODE_FRIENDLY_NAME;
import static ai.distil.integration.utils.HashHelper.STRING_FUNNEL;


/**
 * S - means subscriber (member, etc..)
 */

@Slf4j
@AllArgsConstructor
public abstract class AbstractDataSync<C extends AbstractHttpConnection, S extends AbstractSubscriber> {
    private static final Integer DEFAULT_BATCH_SIZE = 100;
    private static final String LIST_NAME_TEMPLATE = "DISTIL-%s";
    private static final long DEFAULT_HASH_CODE_FIELD_ID = -1000_000L;

    protected DestinationIntegrationDTO destinationIntegration;
    private List<DTODataSourceAttributeExtended> attributes;
    protected SyncSettings syncSettings;
    protected C httpConnection;

    /**
     * @return list id
     */
    public abstract String createListIfNotExists();

    public abstract List<CustomAttributeDefinition> syncCustomAttributesSchema(String listId);

    protected abstract Set<String> retrieveCurrentEmails(String listId);

    protected String buildListName(Long destinationId) {
        return String.format(LIST_NAME_TEMPLATE, destinationId).toUpperCase().trim();
    }

    protected String buildFieldId(Long id) {
        return String.format("D-%s", id);
    }

    protected List<DTODataSourceAttributeExtended> retrieveAllAttributesBySettings() {
        Integer defaultProductsCount = this.syncSettings.getDefaultProductsCount();

        return Stream.concat(this.attributes.stream()
                        .filter(attr -> !attr.getAutoGenerated() || attr.getPosition() <= defaultProductsCount),
                Stream.of(getDefaultHashField()))
                .collect(Collectors.toList());
    }

    protected DTODataSourceAttributeExtended getDefaultHashField() {
        DTODataSourceAttributeExtended attr = new DTODataSourceAttributeExtended(true);
        attr.setAttributeDisplayName(HASH_CODE_FRIENDLY_NAME);
        attr.setId(DEFAULT_HASH_CODE_FIELD_ID);
        attr.setAttributeDataTag(DataSourceSchemaAttributeTag.NONE);
        attr.setPosition(1);

        return attr;
    }

    protected abstract S buildBaseSubscriber();

    protected abstract void addCustomField(S subscriber, String fieldName, String value);

    protected abstract void sendSubscribers(String listId, List<S> subscribers);

    protected abstract void removeSubscribers(String listId, Collection<String> subscribersIds);


    public void ingestData(String listId, List<CustomAttributeDefinition> attributes, List<CustomerRecord> data) {
        SyncDestinationProgressData progressData = new SyncDestinationProgressData();

//        sort attributes first, it's required for current products logic
        attributes.sort(Comparator.comparing(cad -> Optional.ofNullable(cad).map(CustomAttributeDefinition::getPosition).orElse(-1)));

        Map<DataSourceSchemaAttributeTag, Set<String>> attributesToBackfill = ListUtils.groupByToLinkedSet(this.attributes.stream()
                        .filter(DTODataSourceAttributeExtended::getAutoGenerated)
                        .sorted(Comparator.comparingInt(DTODataSourceAttributeExtended::getPosition)).collect(Collectors.toList()),
                DTODataSourceAttributeExtended::getAttributeDataTag, dsa -> String.valueOf(dsa.getId()));

        Set<String> currentSubscribers = retrieveCurrentEmails(listId);
        progressData.setBeforeRowsCount(currentSubscribers.size());

        List<S> subscribers = new ArrayList<>();

        data.forEach(record -> {
            S subscriber = generateSubscriberData(attributes, record, attributesToBackfill);
            if (subscriber == null) {
                progressData.incrementExcludersCounter();
            } else {

                subscribers.add(subscriber);

                if (currentSubscribers.remove(subscriber.getEmailAddress())) {
                    progressData.incrementUpdatesCounter();
                } else {
                    progressData.incrementCreatesCounter();
                }
//                todo not changed count
            }

            if (subscribers.size() > DEFAULT_BATCH_SIZE) {
                sendSubscribers(listId, subscribers);
                subscribers.clear();
            }
        });

        if (subscribers.size() > 0) {
            sendSubscribers(listId, subscribers);
            subscribers.clear();
        }

        log.info("Subscribers to delete -> {}", currentSubscribers.size());

        progressData.setDeleted(currentSubscribers.size());

        removeSubscribers(listId, currentSubscribers);

//      todo newsfeed card?
        log.info("Successfully finished data sync for the integration - result {}", progressData);

    }

    protected S generateSubscriberData(List<CustomAttributeDefinition> attributes, CustomerRecord data, Map<DataSourceSchemaAttributeTag, Set<String>> fieldToBackfillByTags) {
        Hasher hasher = Hashing.sha1().newHasher();

        Set<String> attributesProcessed = new HashSet<>();

        ObjectNode customerValues = data.getCustomerValues();

        S result = buildBaseSubscriber();

        for (CustomAttributeDefinition attr : attributes) {

            String distilAttributeId = String.valueOf(attr.getDistilAttributeId());
            attributesProcessed.add(distilAttributeId);

            Optional<String> valueOptional = getValueAndUpdateHashIfNotNull(customerValues.get(distilAttributeId), hasher);
            boolean isAutoGeneratedAttr = Boolean.TRUE.equals(attr.getAutoGeneratedAttribute());

//            handle value present
            valueOptional.ifPresent(value -> {

                switch (attr.getTag()) {
                    case CUSTOMER_EMAIL_ADDRESS:
                        result.setEmail(value);
                        return;
                    case CUSTOMER_FIRST_NAME:
                        result.setFirstName(value);
                        return;
                    case CUSTOMER_LAST_NAME:
                        result.setLastName(value);
                        return;
                }

            });

            if (isProductDataSource(attr) && !valueOptional.isPresent() && isAutoGeneratedAttr) {

                Set<String> fieldsToBackfill = new HashSet<>(fieldToBackfillByTags.getOrDefault(attr.getTag(), Collections.emptySet()));
                fieldsToBackfill.removeAll(attributesProcessed);

                for (String s : fieldsToBackfill) {
                    attributesProcessed.add(s);

                    getValueAndUpdateHashIfNotNull(customerValues.get(s), hasher)
                            .ifPresent(value -> this.addCustomField(result, attr.getId(), value));

//                      this means that some auto generated required column can't be backfilled that's why we need to skip this consumer
                    return null;
                }
            } else if (valueOptional.isPresent()) {
                String value = valueOptional.get();
                this.addCustomField(result, attr.getId(), value);
            }
        }

        result.setHashCode(buildFieldId(DEFAULT_HASH_CODE_FIELD_ID), hasher.hash().toString());

        return result;
    }

    private boolean isProductDataSource(CustomAttributeDefinition attr) {
        return DataSourceType.PRODUCT.equals(attr.getTag().getDataSourceType());
    }

    /**
     * WARN: impure, modifying hash
     */
    private Optional<String> getValueAndUpdateHashIfNotNull(JsonNode node, Hasher hasher) {

        return Optional.ofNullable(node)
                .filter(((Predicate<JsonNode>) JsonNode::isNull).negate())
                .map((v) -> {
                    String result = v.asText();
                    hasher.putObject(result, STRING_FUNNEL);
                    return result;
                });

    }


}
